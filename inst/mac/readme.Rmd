---
title: "readme"
author: "alfonso reyes"
date: "September 22, 2016"
output: 
    html_document:
    toc: true
    highlight: zenburn
---
# Wrapper for helloA
```{r}
# Wrapper function to invoke "helloA" at the shell.
helloA <- function() {
  system(paste(getwd(),"helloA",sep="/"))
}
```
## calling helloA
```{r}
a <- helloA()
```


Add a R wrapper for the function helloB():

```{r}
# Wrapper function to invoke helloB with a named argument
dyn.load("helloB.so")
helloB <- function() {
  result <- .C("helloB", greeting="")
  return(result$greeting)
}
```

```{r}
helloB()
```

```{r}
#Wrapper function to invoke helloC with two arguments
dyn.load("helloC.so")
helloC <- function(greeting) {
  if (!is.character(greeting)) {
    stop("Argument 'greeting' must be of type 'character'.")
  }
  result <- .C("helloC",
               greeting=greeting,
               count=as.integer(1))
  return(result$count)
}
```

```{r}
helloC("Hi there!")
```

```{r}
# wrapper function to invoke cconv 
dyn.load("cconv.so")
rconv <- function(lag,x) {
 .C("cconv",
  as.integer(lag),
  as.double(x),
  as.integer(length(x)),
  as.double(0.0))[[4]]
}
```
"Observe that we convert all arguments to the approriate type (just to be sure). The .C function returns a list with all its arguments, we only need the last (fourth) argument. In this case we did not name the last argument but extracted it using a numeric index. Whether one uses named arguments (as in Section 5.1) or numeric indices is a matter of personal preference.""
```{r}
x <- rnorm(100)
rconv(0, x)
```

```{r}
x <- rnorm(100)
rconv(1, x)
```

With a little bit more trouble we can vectorize this, 
i.e. make it accept a vector of lags and return a vector of 
convolutions of the same length. The C code now becomes:

void cconv (int *l, int *m, double *x, int *n, double *s)
{
  double *y, *z, *u;
  int i;
  for (i = 0; i < *m; i++)
    {
      y = x + (*n - l[i]);
      z = x + l[i];
      u = x;
      s[i] = 0.0;
      while (u < y)
        s[i] += *u++ * *z++;
    }
}


